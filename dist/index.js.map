{"version":3,"file":"index.js","sources":["../src/is-of-node-type/index.ts","../src/get-type-safe-node/index.ts","../src/generate-code-from-ast/index.ts","../src/generate-ast-from-code/index.ts","../src/utils/create-function-name-definition.ts","../src/parse-function-or-class-name/utils/get-name-from-export-specifier.ts","../src/parse-function-or-class-name/utils/parse-node-type.ts","../src/parse-function-or-class-name/utils/get-parameters-from-node.ts","../src/parse-function-or-class-name/utils/get-name-from-default-exported-declaration.ts","../src/parse-function-or-class-name/get-function-or-class-name-from-export-statements.ts","../src/parse-function-or-class-name/index.ts","../src/utils/parse-text-document.ts","../src/get-file-info/get-file-info.ts"],"sourcesContent":["import { Node } from \"@babel/types\";\n\n/**\n * Checks if a recast AST Node is a declaration of a given type\n *\n * @example\n * const code = `export const myFunction = (a: number, b: number): number => a + b;`;\n * const ast = generateAstFromCode(code);\n *\n * const baseNode = ast.program.body[0];\n *\n * if (\n *   isOfNodeType<ExportNamedDeclaration>(\n *     baseNode,\n *     \"ExportNamedDeclaration\"\n *   )\n * ) {\n *   // this is true (in this example)\n * }\n *\n * @param node A node in a recast AST\n * @param declarationName The name of the node type, usually found in the .type property of the node\n * @returns true if the node is a declaration of the given type, false otherwise\n */\nexport const isOfNodeType = <T extends Node>(\n  node: any,\n  declarationName: string | string[]\n): node is T => {\n  if (Array.isArray(declarationName)) {\n    return declarationName.every((name) => isOfNodeType(node, name));\n  }\n\n  return node && node.type === declarationName;\n};\n","import { Node } from \"@babel/types\";\nimport { isOfNodeType } from \"../is-of-node-type\";\n\n/**\n * This function takes in a node and a declaration name, and returns the node casted to the given type.\n * \n * @param node A node in a recast AST\n * @param declarationName The name of the node type, usually found in the .type property of the node\n * @returns The node casted to the given type\n * @throws Error if the node is undefined, or if the node is not of the given type\n */\nexport const getTypeSafeNode = <T extends Node>(\n  node: Node,\n  declarationName: string // TODO: if this can in anyway be inferred from T, that would be great\n): T => {\n  if (!node) {\n    throw new Error(\"Node is undefined\");\n  }\n\n  if (node.type !== declarationName) {\n    throw new Error(`Expected ${declarationName} but got ${node.type}`);\n  }\n\n  if (!isOfNodeType<T>(node, declarationName)) {\n    throw new Error(`Expected node to be of type ${declarationName}`);\n  }\n\n  return node;\n};\n","import { Options, prettyPrint } from \"recast\";\nimport { File } from \"@babel/types\";\n\n/**\n * Generates a code string from a recast AST\n *\n * @param ast An AST that has been generated from a code string using recast\n * @param options Options for pretty printing the code\n * @returns A string representing the code in the AST\n */\nexport const generateCodeFromAST = (ast: File, options?: Options): string =>\n  prettyPrint(ast, options).code;\n","import { File } from \"@babel/types\";\nimport { parse } from \"recast\";\n\n/**\n * Generates an AST from a string of code\n *\n * @example\n * const code = `export const myFunction = (a: number, b: number): number => a + b;`;\n * const ast = generateAstFromCode(code);\n * \n * @param code A string of code to generate an AST from\n * @returns An AST of the code\n */\nexport const generateAstFromCode = (code: string): File => {\n  return parse(code, {\n    parser: require(\"recast/parsers/babel-ts\"),\n  }) as File;\n};\n","import { Node } from \"@babel/types\";\nimport { FunctionParameter } from \"../parse-function-or-class-name/types\";\n\nexport const createFunctionNameDefinition = (options: {\n  name: string;\n  parameters: FunctionParameter[];\n  node: Node;\n  isClass?: boolean;\n  isDefault?: boolean;\n  isOptional?: boolean;\n}) => ({\n  name: options.name,\n  isClass: options.isClass || false,\n  isDefault: options.isDefault || false,\n  isOptional: options.isOptional || false,\n  parameters: options.parameters,\n  node: options.node,\n});\n","import {\n  ExportDefaultSpecifier,\n  ExportNamespaceSpecifier,\n  ExportSpecifier,\n  Identifier,\n} from \"@babel/types\";\nimport { isOfNodeType } from \"../../is-of-node-type\";\nimport { FunctionNameDefinition } from \"../types\";\nimport { createFunctionNameDefinition } from \"../../utils/create-function-name-definition\";\nimport { getParametersFromNode } from \"./get-parameters-from-node\";\n\nexport const getNameFromExportSpecifier = (\n  exportedFunction:\n    | ExportDefaultSpecifier\n    | ExportNamespaceSpecifier\n    | ExportSpecifier\n): FunctionNameDefinition => {\n  const functionNameDefinition = createFunctionNameDefinition({\n    name: \"\",\n    node: exportedFunction,\n    parameters: [],\n  });\n\n  if (\n    isOfNodeType<ExportDefaultSpecifier>(\n      exportedFunction,\n      \"ExportDefaultSpecifier\"\n    )\n  ) {\n    return {\n      ...functionNameDefinition,\n      name: exportedFunction.exported.name,\n      isDefault: true,\n    };\n  }\n\n  if (\n    isOfNodeType<ExportSpecifier>(exportedFunction, \"ExportSpecifier\") ||\n    isOfNodeType<ExportNamespaceSpecifier>(\n      exportedFunction,\n      \"ExportNamespaceSpecifier\"\n    )\n  ) {\n    if (isOfNodeType<Identifier>(exportedFunction.exported, \"Identifier\")) {\n      return {\n        ...functionNameDefinition,\n        name: exportedFunction.exported.name,\n      };\n    }\n\n    return {\n      ...functionNameDefinition,\n      name: \"default\",\n      isDefault: true,\n    };\n  }\n\n  return functionNameDefinition;\n};\n","const typeStructures = [\n  \"Keyword\",\n  \"Type\",\n  \"Predicate\",\n  \"Query\",\n];\n\nexport const parseNodeType = (nodeDataType: string) => {\n  for (const typeStructure of typeStructures) {\n    if (nodeDataType.endsWith(typeStructure)) {\n      const regex = new RegExp(`TS(.*?)${typeStructure}`, \"g\");\n      return nodeDataType\n        .replace(regex, \" $1\")\n        .trim()\n        .toLowerCase();\n    }\n  }\n\n  // For everyting else, we just remove the TS prefix and lowercase the first letter\n  // e.g. TSTypeLiteral -> typeLiteral\n  const result = nodeDataType.replace(/TS(.*?)/g, \" $1\").trim();\n  return result.replace(/^.{1}/g, result[0].toLowerCase());\n};\n","import {\n  ClassBody,\n  ClassDeclaration,\n  ClassMethod,\n  Declaration,\n  Expression,\n  Identifier,\n  ObjectPattern,\n  ObjectProperty,\n  Pattern,\n  RestElement,\n  VariableDeclarator,\n} from \"@babel/types\";\nimport { isOfNodeType } from \"../../is-of-node-type\";\nimport { FunctionParameter } from \"../types\";\nimport { identifier } from \"@babel/types\";\nimport { parseNodeType } from \"./parse-node-type\";\n\nexport const getParametersFromNode = (\n  node: Declaration | VariableDeclarator | Expression\n): FunctionParameter[] => {\n  let params: (Identifier | RestElement | Pattern)[] = [];\n  if (\"params\" in node) {\n    params = node.params as Identifier[];\n  } else if (\"init\" in node && node.init && \"params\" in node.init) {\n    if (node.init.params.length === 1) {\n      if (isOfNodeType<ObjectPattern>(node.init.params[0], \"ObjectPattern\")) {\n        const objectPattern = node.init.params[0];\n        if (\"properties\" in objectPattern && objectPattern.properties) {\n          params = objectPattern.properties\n            .filter(\n              (property) =>\n                \"key\" in property &&\n                isOfNodeType<Identifier>(property.key, \"Identifier\")\n            )\n            .reduce((acc, property) => {\n              if (\"key\" in property && \"name\" in property.key) {\n                const identifier: Identifier = {\n                  name: property.key.name,\n                  type: \"Identifier\",\n                  optional: false,\n                };\n                return [...acc, identifier];\n              }\n\n              return acc;\n            }, [] as Identifier[]);\n        }\n      }\n    } else {\n      params = node.init.params;\n    }\n  } else if (\n    isOfNodeType<VariableDeclarator>(node, \"VariableDeclarator\") &&\n    node.init &&\n    \"params\" in node.init\n  ) {\n    params = node.init.params;\n  } else if (isOfNodeType<Expression>(node, \"Expression\")) {\n  } else if (isOfNodeType<ClassDeclaration>(node, \"ClassDeclaration\")) {\n    const outerBoddy = node.body;\n    if (isOfNodeType<ClassBody>(outerBoddy, \"ClassBody\")) {\n      const innerBodies = outerBoddy.body;\n      const classConstructor = innerBodies.find(\n        (body) =>\n          isOfNodeType<ClassMethod>(body, \"ClassMethod\") &&\n          body.kind === \"constructor\"\n      );\n      if (classConstructor) {\n        if (\"params\" in classConstructor) {\n          params = classConstructor.params.filter((param) => \"name\" in param);\n        }\n      }\n    }\n  }\n\n  return params\n    .filter((params) => \"name\" in params)\n    .map((param) => {\n      const type =\n        param.typeAnnotation && \"typeAnnotation\" in param.typeAnnotation\n          ? param.typeAnnotation.typeAnnotation.type\n          : \"TSAnyKeyword\";\n      return {\n        name: param.name,\n        type: parseNodeType(type),\n        tsType: type,\n        isOptional: param.optional || false,\n      };\n    });\n};\n","import { ExportDefaultDeclaration, Expression, isClass } from \"@babel/types\";\nimport { FunctionNameDefinition } from \"../types\";\nimport { isOfNodeType } from \"../../is-of-node-type\";\nimport { createFunctionNameDefinition } from \"../../utils/create-function-name-definition\";\nimport { getParametersFromNode } from \"./get-parameters-from-node\";\n\nexport const getNameFromDefaultExportedDeclaration = (\n  defaultExportedDeclaration: ExportDefaultDeclaration\n): FunctionNameDefinition => {\n  if (\n    isOfNodeType<Expression>(\n      defaultExportedDeclaration.declaration,\n      \"Expression\"\n    )\n  ) {\n    return createFunctionNameDefinition({\n      name: \"default\",\n      isDefault: true,\n      node: defaultExportedDeclaration.declaration,\n      parameters: getParametersFromNode(defaultExportedDeclaration.declaration),\n    });\n  }\n\n  if (defaultExportedDeclaration && defaultExportedDeclaration.declaration) {\n    let name = \"default\";\n\n    if (\"id\" in defaultExportedDeclaration.declaration) {\n      name = defaultExportedDeclaration.declaration.id?.name || \"\";\n    }\n\n    return createFunctionNameDefinition({\n      name,\n      isClass: isClass(defaultExportedDeclaration.declaration),\n      isDefault: true,\n      node: defaultExportedDeclaration.declaration,\n      parameters: getParametersFromNode(defaultExportedDeclaration.declaration),\n    });\n  }\n\n  const name =\n    (\"name\" in defaultExportedDeclaration.declaration\n      ? (defaultExportedDeclaration.declaration.name as string)\n      : defaultExportedDeclaration.declaration.id?.name) || \"\";\n\n  return createFunctionNameDefinition({\n    name,\n    isClass: isClass(defaultExportedDeclaration.declaration),\n    isDefault: true,\n    node: defaultExportedDeclaration.declaration,\n    parameters: getParametersFromNode(defaultExportedDeclaration.declaration),\n  });\n};\n","import {\n  ClassDeclaration,\n  DeclareExportAllDeclaration,\n  ExportAllDeclaration,\n  ExportDefaultDeclaration,\n  ExportDefaultSpecifier,\n  ExportNamedDeclaration,\n  ExportNamespaceSpecifier,\n  ExportSpecifier,\n  Expression,\n  FunctionExpression,\n  Identifier,\n  isClass,\n  ObjectPattern,\n  ObjectProperty,\n  Statement,\n  TSType,\n  VariableDeclaration,\n} from \"@babel/types\";\nimport { getTypeSafeNode } from \"../get-type-safe-node\";\nimport { FunctionNameDefinition, FunctionParameter } from \"./types\";\nimport { isOfNodeType } from \"../is-of-node-type\";\nimport { getNameFromExportSpecifier } from \"./utils/get-name-from-export-specifier\";\nimport { getNameFromDefaultExportedDeclaration } from \"./utils/get-name-from-default-exported-declaration\";\nimport { createFunctionNameDefinition } from \"../utils/create-function-name-definition\";\nimport { getParametersFromNode } from \"./utils/get-parameters-from-node\";\n\nexport const getFunctionOrClassNameFromExportStatements = (\n  statement: Statement\n): FunctionNameDefinition[] => {\n  const exportedFunctionNames: FunctionNameDefinition[] = [];\n\n  const exportedFunction = getTypeSafeNode<\n    ExportNamedDeclaration | ExportDefaultDeclaration | ExportAllDeclaration\n  >(statement, statement.type);\n  if (\n    isOfNodeType<ExportDefaultDeclaration>(\n      exportedFunction,\n      \"ExportDefaultDeclaration\"\n    )\n  ) {\n    exportedFunctionNames.push(\n      getNameFromDefaultExportedDeclaration(exportedFunction)\n    );\n  }\n\n  if (\n    isOfNodeType<ExportNamedDeclaration>(\n      exportedFunction,\n      \"ExportNamedDeclaration\"\n    )\n  ) {\n    const namedExportedFunction = exportedFunction as ExportNamedDeclaration;\n    if (\n      namedExportedFunction.specifiers &&\n      namedExportedFunction.specifiers.length > 0\n    ) {\n      namedExportedFunction.specifiers.forEach((specifier) => {\n        if (\n          !isOfNodeType<\n            ExportSpecifier | ExportDefaultSpecifier | ExportNamespaceSpecifier\n          >(specifier, [\n            \"ExportSpecifier\",\n            \"ExportDefaultSpecifier\",\n            \"ExportNamespaceSpecifier\",\n          ])\n        ) {\n          const exportedFunction = getNameFromExportSpecifier(specifier);\n          exportedFunctionNames.push(exportedFunction);\n        } else {\n          // TODO: Handle this case\n        }\n      });\n    } else if (namedExportedFunction.declaration) {\n      if (\n        !isOfNodeType<Expression>(\n          namedExportedFunction.declaration,\n          \"Expression\"\n        )\n      ) {\n        if (\n          isOfNodeType<VariableDeclaration>(\n            namedExportedFunction.declaration,\n            \"VariableDeclaration\"\n          )\n        ) {\n          namedExportedFunction.declaration.declarations.forEach(\n            (declaration) => {\n              if (isOfNodeType<Identifier>(declaration.id, \"Identifier\")) {\n                exportedFunctionNames.push(\n                  createFunctionNameDefinition({\n                    name: declaration.id.name,\n                    isClass: isClass(declaration),\n                    node: declaration,\n                    parameters: getParametersFromNode(declaration),\n                  })\n                );\n              } else if (\n                isOfNodeType<ObjectPattern>(declaration.id, \"ObjectPattern\")\n              ) {\n                declaration.id.properties.forEach((property) => {\n                  if (\n                    isOfNodeType<ObjectProperty>(property, \"ObjectProperty\")\n                  ) {\n                    if (isOfNodeType<Identifier>(property.key, \"Identifier\")) {\n                      exportedFunctionNames.push(\n                        createFunctionNameDefinition({\n                          name: property.key.name,\n                          isClass: isClass(declaration),\n                          node: declaration,\n                          parameters: getParametersFromNode(declaration),\n                        })\n                      );\n                    }\n                  }\n                });\n              } else {\n                const name = declaration.id.toString();\n                if (name) {\n                  exportedFunctionNames.push(\n                    createFunctionNameDefinition({\n                      name,\n                      isClass: isClass(declaration),\n                      node: declaration,\n                      parameters: getParametersFromNode(declaration),\n                    })\n                  );\n                }\n              }\n            }\n          );\n        } else if (\n          isOfNodeType<ClassDeclaration>(\n            namedExportedFunction.declaration,\n            \"ClassDeclaration\"\n          )\n        ) {\n          const declarationName = namedExportedFunction.declaration.id?.name;\n          const forcedIdentifierName =\n            namedExportedFunction.declaration.id?.toString();\n          const name = declarationName || forcedIdentifierName || \"\";\n\n          if (!name) {\n            throw new Error(\"Could not identify node name\");\n          }\n\n          exportedFunctionNames.push(\n            createFunctionNameDefinition({\n              name,\n              isClass: true,\n              node: namedExportedFunction.declaration,\n              parameters: getParametersFromNode(namedExportedFunction.declaration),\n            })\n          );\n        } else {\n          const declaration = namedExportedFunction.declaration;\n          if (\n            isOfNodeType<DeclareExportAllDeclaration>(\n              declaration,\n              \"DeclareExportAllDeclaration\"\n            )\n          ) {\n          } else {\n            if (declaration && \"id\" in declaration) {\n              if (isOfNodeType<Identifier>(declaration.id, \"Identifier\")) {\n                const name = declaration.id.name;\n                if (name) {\n                  exportedFunctionNames.push(\n                    createFunctionNameDefinition({\n                      name,\n                      isClass: isClass(declaration),\n                      node: declaration,\n                      parameters: getParametersFromNode(declaration),\n                    })\n                  );\n                }\n              } else {\n                exportedFunctionNames.push(\n                  createFunctionNameDefinition({\n                    name: declaration.id?.toString() || \"\",\n                    isClass: isClass(declaration),\n                    node: declaration,\n                    parameters: getParametersFromNode(declaration),\n                  })\n                );\n              }\n            } else {\n              // Ignore\n            }\n          }\n        }\n      }\n    } else if (\n      isOfNodeType<ExportAllDeclaration>(\n        exportedFunction,\n        \"ExportAllDeclaration\"\n      )\n    ) {\n      // Ignore\n    } else {\n      throw new Error(\"This should not be possible!\");\n    }\n  }\n\n  return exportedFunctionNames;\n};\n","import { File } from \"@babel/types\";\nimport { generateAstFromCode } from \"../generate-ast-from-code\";\nimport { getFunctionOrClassNameFromExportStatements } from \"./get-function-or-class-name-from-export-statements\";\nimport { FunctionNameDefinition } from \"./types\";\n\n/**\n * This function takes in a string of code or an AST and returns the name of the function or class, and a boolean indicating if it is a class.\n *\n * @example\n * const code = `export const myFunction = (a: number, b: number): number => a + b;`;\n * const ast = generateAstFromCode(code);\n *\n * const results = parseFunctionOrClass(ast);\n *\n * const node = results[0];\n * const parameters = node.parameters;\n *\n * // [{\"name\":\"a\",\"type\":\"number\",\"tsType\":\"TSNumberKeyword\",\"isOptional\":false},{\"name\":\"b\",\"type\":\"number\",\"tsType\":\"TSNumberKeyword\",\"isOptional\":false}]\n *\n * @param code Either a string representation of the code to parse, or an AST of the code.\n * @returns A FunctionNameDefinition object with the name of the function or class, and a boolean indicating if it is a class.\n * @throws Error if the code does not correspond to a standard AST, or if the code does not contain a function or class.\n */\nexport const parseFunctionOrClass = (\n  code: string | File\n): FunctionNameDefinition[] => {\n  const ast: File = typeof code === \"string\" ? generateAstFromCode(code) : code;\n\n  const exportStatements = ast.program.body.filter(\n    (bodyPart: { type: string }) =>\n      bodyPart.type === \"ExportNamedDeclaration\" ||\n      bodyPart.type === \"ExportDefaultDeclaration\"\n  );\n\n  const hasTooFewExports = exportStatements.length < 1;\n  if (hasTooFewExports) {\n    return [];\n  }\n\n  const acceptableExportedTypes = [\n    \"ExportNamedDeclaration\",\n    \"ExportDefaultDeclaration\",\n  ];\n\n  if (!acceptableExportedTypes.includes(exportStatements[0].type)) {\n    // TODO: is this me being anal retentive? Can this never happen?\n    throw new Error(\n      \"This extension only works with named or default exports. Please add a named or default export to the function or class.\"\n    );\n  }\n\n  return exportStatements\n    .map((statement) => getFunctionOrClassNameFromExportStatements(statement))\n    .flat();\n};\n","import * as vscode from \"vscode\";\nimport path from \"path\";\n\ntype ReturnData = {\n  text: string;\n  currentlyOpenFileUri: vscode.Uri;\n  fileName: string;\n  fileExtension?: string;\n};\n\nexport const parseTextDocument = async (\n  doc: vscode.TextDocument | undefined\n): Promise<ReturnData> => {\n  if (!doc) {\n    throw new Error(\"currently open file uri could not be determined.\");\n  }\n\n  if (doc.fileName.includes(\".test.\")) {\n    const fileName = path.basename(doc.fileName);\n    throw new Error(`The file \"${fileName}\" is already a test file.`);\n  }\n\n  const text = doc.getText();\n  const fileName = doc.fileName;\n  const fileExtension = fileName.split(\".\").pop();\n\n  const currentlyOpenFileUri = doc.uri;\n\n  return { text, currentlyOpenFileUri, fileExtension, fileName };\n};\n","import * as vscode from \"vscode\";\nimport fs from \"fs\";\nimport { parseTextDocument } from \"../utils/parse-text-document\";\nimport path from \"path\";\n\n/**\n * Get the content and information about a file on disk, or the currently open file in the editor.\n * @param filePath The path to the file on disk, or undefined to get the currently open file in the editor.\n * @returns The text content of the file, the URI of the currently open file, and the file name and extension.\n */\nexport const getFileInfo = async (filePath?: string) => {\n  let text = \"\";\n  let fileName = \"\";\n  let fileExtension = \"\";\n  let currentlyOpenFileUri = vscode.Uri.file(\"\");\n\n  if (filePath) {\n    text = fs.readFileSync(filePath, \"utf8\");\n    fileName = filePath.split(\"/\").pop() || \"\";\n    fileExtension = fileName.includes(\".\")\n      ? filePath.split(\".\").pop() || \"\"\n      : \"\";\n    currentlyOpenFileUri = vscode.Uri.file(filePath);\n  } else {\n    const document = vscode.window.activeTextEditor?.document;\n    const documentInfo = await parseTextDocument(document);\n    text = documentInfo.text;\n    fileName = documentInfo.fileName;\n    fileExtension = documentInfo.fileExtension || \"\";\n    currentlyOpenFileUri = documentInfo.currentlyOpenFileUri;\n  }\n\n  if (!fileExtension) {\n    fileExtension = \"js\";\n  }\n\n  const dir = path.dirname(currentlyOpenFileUri.fsPath);\n\n  return { text, currentlyOpenFileUri, fileExtension, fileName, dir };\n};\n"],"names":["prettyPrint","parse","isClass","vscode"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;AAqBG;MACU,YAAY,GAAG,CAC1B,IAAS,EACT,eAAkC,KACrB;AACb,IAAA,IAAI,KAAK,CAAC,OAAO,CAAC,eAAe,CAAC,EAAE;AAClC,QAAA,OAAO,eAAe,CAAC,KAAK,CAAC,CAAC,IAAI,KAAK,YAAY,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC,CAAC;KAClE;AAED,IAAA,OAAO,IAAI,IAAI,IAAI,CAAC,IAAI,KAAK,eAAe,CAAC;AAC/C;;AC9BA;;;;;;;AAOG;MACU,eAAe,GAAG,CAC7B,IAAU,EACV,eAAuB;KAClB;IACL,IAAI,CAAC,IAAI,EAAE;AACT,QAAA,MAAM,IAAI,KAAK,CAAC,mBAAmB,CAAC,CAAC;KACtC;AAED,IAAA,IAAI,IAAI,CAAC,IAAI,KAAK,eAAe,EAAE;QACjC,MAAM,IAAI,KAAK,CAAC,CAAY,SAAA,EAAA,eAAe,CAAY,SAAA,EAAA,IAAI,CAAC,IAAI,CAAE,CAAA,CAAC,CAAC;KACrE;IAED,IAAI,CAAC,YAAY,CAAI,IAAI,EAAE,eAAe,CAAC,EAAE;AAC3C,QAAA,MAAM,IAAI,KAAK,CAAC,+BAA+B,eAAe,CAAA,CAAE,CAAC,CAAC;KACnE;AAED,IAAA,OAAO,IAAI,CAAC;AACd;;ACzBA;;;;;;AAMG;AACU,MAAA,mBAAmB,GAAG,CAAC,GAAS,EAAE,OAAiB,KAC9DA,kBAAW,CAAC,GAAG,EAAE,OAAO,CAAC,CAAC;;ACR5B;;;;;;;;;AASG;AACU,MAAA,mBAAmB,GAAG,CAAC,IAAY,KAAU;IACxD,OAAOC,YAAK,CAAC,IAAI,EAAE;AACjB,QAAA,MAAM,EAAE,OAAO,CAAC,yBAAyB,CAAC;AAC3C,KAAA,CAAS,CAAC;AACb;;ACdO,MAAM,4BAA4B,GAAG,CAAC,OAO5C,MAAM;IACL,IAAI,EAAE,OAAO,CAAC,IAAI;AAClB,IAAA,OAAO,EAAE,OAAO,CAAC,OAAO,IAAI,KAAK;AACjC,IAAA,SAAS,EAAE,OAAO,CAAC,SAAS,IAAI,KAAK;AACrC,IAAA,UAAU,EAAE,OAAO,CAAC,UAAU,IAAI,KAAK;IACvC,UAAU,EAAE,OAAO,CAAC,UAAU;IAC9B,IAAI,EAAE,OAAO,CAAC,IAAI;AACnB,CAAA,CAAC;;ACNK,MAAM,0BAA0B,GAAG,CACxC,gBAGmB,KACO;IAC1B,MAAM,sBAAsB,GAAG,4BAA4B,CAAC;AAC1D,QAAA,IAAI,EAAE,EAAE;AACR,QAAA,IAAI,EAAE,gBAAgB;AACtB,QAAA,UAAU,EAAE,EAAE;AACf,KAAA,CAAC,CAAC;AAEH,IAAA,IACE,YAAY,CACV,gBAAgB,EAChB,wBAAwB,CACzB,EACD;AACA,QAAA,OAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACK,sBAAsB,CAAA,EAAA,EACzB,IAAI,EAAE,gBAAgB,CAAC,QAAQ,CAAC,IAAI,EACpC,SAAS,EAAE,IAAI,EACf,CAAA,CAAA;KACH;AAED,IAAA,IACE,YAAY,CAAkB,gBAAgB,EAAE,iBAAiB,CAAC;AAClE,QAAA,YAAY,CACV,gBAAgB,EAChB,0BAA0B,CAC3B,EACD;QACA,IAAI,YAAY,CAAa,gBAAgB,CAAC,QAAQ,EAAE,YAAY,CAAC,EAAE;YACrE,OACK,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EAAA,sBAAsB,KACzB,IAAI,EAAE,gBAAgB,CAAC,QAAQ,CAAC,IAAI,EACpC,CAAA,CAAA;SACH;QAED,OACK,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EAAA,sBAAsB,KACzB,IAAI,EAAE,SAAS,EACf,SAAS,EAAE,IAAI,EACf,CAAA,CAAA;KACH;AAED,IAAA,OAAO,sBAAsB,CAAC;AAChC,CAAC;;AC1DD,MAAM,cAAc,GAAG;IACrB,SAAS;IACT,MAAM;IACN,WAAW;IACX,OAAO;CACR,CAAC;AAEK,MAAM,aAAa,GAAG,CAAC,YAAoB,KAAI;AACpD,IAAA,KAAK,MAAM,aAAa,IAAI,cAAc,EAAE;AAC1C,QAAA,IAAI,YAAY,CAAC,QAAQ,CAAC,aAAa,CAAC,EAAE;YACxC,MAAM,KAAK,GAAG,IAAI,MAAM,CAAC,CAAU,OAAA,EAAA,aAAa,CAAE,CAAA,EAAE,GAAG,CAAC,CAAC;AACzD,YAAA,OAAO,YAAY;AAChB,iBAAA,OAAO,CAAC,KAAK,EAAE,KAAK,CAAC;AACrB,iBAAA,IAAI,EAAE;AACN,iBAAA,WAAW,EAAE,CAAC;SAClB;KACF;;;AAID,IAAA,MAAM,MAAM,GAAG,YAAY,CAAC,OAAO,CAAC,UAAU,EAAE,KAAK,CAAC,CAAC,IAAI,EAAE,CAAC;AAC9D,IAAA,OAAO,MAAM,CAAC,OAAO,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC,CAAC,CAAC,WAAW,EAAE,CAAC,CAAC;AAC3D,CAAC;;ACJM,MAAM,qBAAqB,GAAG,CACnC,IAAmD,KAC5B;IACvB,IAAI,MAAM,GAA2C,EAAE,CAAC;AACxD,IAAA,IAAI,QAAQ,IAAI,IAAI,EAAE;AACpB,QAAA,MAAM,GAAG,IAAI,CAAC,MAAsB,CAAC;KACtC;AAAM,SAAA,IAAI,MAAM,IAAI,IAAI,IAAI,IAAI,CAAC,IAAI,IAAI,QAAQ,IAAI,IAAI,CAAC,IAAI,EAAE;QAC/D,IAAI,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,MAAM,KAAK,CAAC,EAAE;AACjC,YAAA,IAAI,YAAY,CAAgB,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,eAAe,CAAC,EAAE;gBACrE,MAAM,aAAa,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;gBAC1C,IAAI,YAAY,IAAI,aAAa,IAAI,aAAa,CAAC,UAAU,EAAE;oBAC7D,MAAM,GAAG,aAAa,CAAC,UAAU;yBAC9B,MAAM,CACL,CAAC,QAAQ,KACP,KAAK,IAAI,QAAQ;AACjB,wBAAA,YAAY,CAAa,QAAQ,CAAC,GAAG,EAAE,YAAY,CAAC,CACvD;AACA,yBAAA,MAAM,CAAC,CAAC,GAAG,EAAE,QAAQ,KAAI;wBACxB,IAAI,KAAK,IAAI,QAAQ,IAAI,MAAM,IAAI,QAAQ,CAAC,GAAG,EAAE;AAC/C,4BAAA,MAAM,UAAU,GAAe;AAC7B,gCAAA,IAAI,EAAE,QAAQ,CAAC,GAAG,CAAC,IAAI;AACvB,gCAAA,IAAI,EAAE,YAAY;AAClB,gCAAA,QAAQ,EAAE,KAAK;6BAChB,CAAC;AACF,4BAAA,OAAO,CAAC,GAAG,GAAG,EAAE,UAAU,CAAC,CAAC;yBAC7B;AAED,wBAAA,OAAO,GAAG,CAAC;qBACZ,EAAE,EAAkB,CAAC,CAAC;iBAC1B;aACF;SACF;aAAM;AACL,YAAA,MAAM,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC;SAC3B;KACF;AAAM,SAAA,IACL,YAAY,CAAqB,IAAI,EAAE,oBAAoB,CAAC;AAC5D,QAAA,IAAI,CAAC,IAAI;AACT,QAAA,QAAQ,IAAI,IAAI,CAAC,IAAI,EACrB;AACA,QAAA,MAAM,GAAG,IAAI,CAAC,IAAI,CAAC,MAAM,CAAC;KAC3B;AAAM,SAAA,IAAI,YAAY,CAAa,IAAI,EAAE,YAAY,CAAC,EAAE,CACxD;AAAM,SAAA,IAAI,YAAY,CAAmB,IAAI,EAAE,kBAAkB,CAAC,EAAE;AACnE,QAAA,MAAM,UAAU,GAAG,IAAI,CAAC,IAAI,CAAC;AAC7B,QAAA,IAAI,YAAY,CAAY,UAAU,EAAE,WAAW,CAAC,EAAE;AACpD,YAAA,MAAM,WAAW,GAAG,UAAU,CAAC,IAAI,CAAC;AACpC,YAAA,MAAM,gBAAgB,GAAG,WAAW,CAAC,IAAI,CACvC,CAAC,IAAI,KACH,YAAY,CAAc,IAAI,EAAE,aAAa,CAAC;AAC9C,gBAAA,IAAI,CAAC,IAAI,KAAK,aAAa,CAC9B,CAAC;YACF,IAAI,gBAAgB,EAAE;AACpB,gBAAA,IAAI,QAAQ,IAAI,gBAAgB,EAAE;AAChC,oBAAA,MAAM,GAAG,gBAAgB,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,KAAK,KAAK,MAAM,IAAI,KAAK,CAAC,CAAC;iBACrE;aACF;SACF;KACF;AAED,IAAA,OAAO,MAAM;SACV,MAAM,CAAC,CAAC,MAAM,KAAK,MAAM,IAAI,MAAM,CAAC;AACpC,SAAA,GAAG,CAAC,CAAC,KAAK,KAAI;QACb,MAAM,IAAI,GACR,KAAK,CAAC,cAAc,IAAI,gBAAgB,IAAI,KAAK,CAAC,cAAc;AAC9D,cAAE,KAAK,CAAC,cAAc,CAAC,cAAc,CAAC,IAAI;cACxC,cAAc,CAAC;QACrB,OAAO;YACL,IAAI,EAAE,KAAK,CAAC,IAAI;AAChB,YAAA,IAAI,EAAE,aAAa,CAAC,IAAI,CAAC;AACzB,YAAA,MAAM,EAAE,IAAI;AACZ,YAAA,UAAU,EAAE,KAAK,CAAC,QAAQ,IAAI,KAAK;SACpC,CAAC;AACJ,KAAC,CAAC,CAAC;AACP,CAAC;;ACpFM,MAAM,qCAAqC,GAAG,CACnD,0BAAoD,KAC1B;;IAC1B,IACE,YAAY,CACV,0BAA0B,CAAC,WAAW,EACtC,YAAY,CACb,EACD;AACA,QAAA,OAAO,4BAA4B,CAAC;AAClC,YAAA,IAAI,EAAE,SAAS;AACf,YAAA,SAAS,EAAE,IAAI;YACf,IAAI,EAAE,0BAA0B,CAAC,WAAW;AAC5C,YAAA,UAAU,EAAE,qBAAqB,CAAC,0BAA0B,CAAC,WAAW,CAAC;AAC1E,SAAA,CAAC,CAAC;KACJ;AAED,IAAA,IAAI,0BAA0B,IAAI,0BAA0B,CAAC,WAAW,EAAE;QACxE,IAAI,IAAI,GAAG,SAAS,CAAC;AAErB,QAAA,IAAI,IAAI,IAAI,0BAA0B,CAAC,WAAW,EAAE;AAClD,YAAA,IAAI,GAAG,CAAA,CAAA,EAAA,GAAA,0BAA0B,CAAC,WAAW,CAAC,EAAE,MAAE,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,EAAA,CAAA,IAAI,KAAI,EAAE,CAAC;SAC9D;AAED,QAAA,OAAO,4BAA4B,CAAC;YAClC,IAAI;AACJ,YAAA,OAAO,EAAEC,aAAO,CAAC,0BAA0B,CAAC,WAAW,CAAC;AACxD,YAAA,SAAS,EAAE,IAAI;YACf,IAAI,EAAE,0BAA0B,CAAC,WAAW;AAC5C,YAAA,UAAU,EAAE,qBAAqB,CAAC,0BAA0B,CAAC,WAAW,CAAC;AAC1E,SAAA,CAAC,CAAC;KACJ;AAED,IAAA,MAAM,IAAI,GACR,CAAC,MAAM,IAAI,0BAA0B,CAAC,WAAW;AAC/C,UAAG,0BAA0B,CAAC,WAAW,CAAC,IAAe;AACzD,UAAE,CAAA,EAAA,GAAA,0BAA0B,CAAC,WAAW,CAAC,EAAE,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,EAAA,CAAE,IAAI,KAAK,EAAE,CAAC;AAE7D,IAAA,OAAO,4BAA4B,CAAC;QAClC,IAAI;AACJ,QAAA,OAAO,EAAEA,aAAO,CAAC,0BAA0B,CAAC,WAAW,CAAC;AACxD,QAAA,SAAS,EAAE,IAAI;QACf,IAAI,EAAE,0BAA0B,CAAC,WAAW;AAC5C,QAAA,UAAU,EAAE,qBAAqB,CAAC,0BAA0B,CAAC,WAAW,CAAC;AAC1E,KAAA,CAAC,CAAC;AACL,CAAC;;ACxBM,MAAM,0CAA0C,GAAG,CACxD,SAAoB,KACQ;;IAC5B,MAAM,qBAAqB,GAA6B,EAAE,CAAC;IAE3D,MAAM,gBAAgB,GAAG,eAAe,CAEtC,SAAS,EAAE,SAAS,CAAC,IAAI,CAAC,CAAC;AAC7B,IAAA,IACE,YAAY,CACV,gBAAgB,EAChB,0BAA0B,CAC3B,EACD;QACA,qBAAqB,CAAC,IAAI,CACxB,qCAAqC,CAAC,gBAAgB,CAAC,CACxD,CAAC;KACH;AAED,IAAA,IACE,YAAY,CACV,gBAAgB,EAChB,wBAAwB,CACzB,EACD;QACA,MAAM,qBAAqB,GAAG,gBAA0C,CAAC;QACzE,IACE,qBAAqB,CAAC,UAAU;AAChC,YAAA,qBAAqB,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,EAC3C;YACA,qBAAqB,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC,SAAS,KAAI;AACrD,gBAAA,IACE,CAAC,YAAY,CAEX,SAAS,EAAE;oBACX,iBAAiB;oBACjB,wBAAwB;oBACxB,0BAA0B;AAC3B,iBAAA,CAAC,EACF;AACA,oBAAA,MAAM,gBAAgB,GAAG,0BAA0B,CAAC,SAAS,CAAC,CAAC;AAC/D,oBAAA,qBAAqB,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;iBAG9C;AACH,aAAC,CAAC,CAAC;SACJ;AAAM,aAAA,IAAI,qBAAqB,CAAC,WAAW,EAAE;YAC5C,IACE,CAAC,YAAY,CACX,qBAAqB,CAAC,WAAW,EACjC,YAAY,CACb,EACD;gBACA,IACE,YAAY,CACV,qBAAqB,CAAC,WAAW,EACjC,qBAAqB,CACtB,EACD;oBACA,qBAAqB,CAAC,WAAW,CAAC,YAAY,CAAC,OAAO,CACpD,CAAC,WAAW,KAAI;wBACd,IAAI,YAAY,CAAa,WAAW,CAAC,EAAE,EAAE,YAAY,CAAC,EAAE;AAC1D,4BAAA,qBAAqB,CAAC,IAAI,CACxB,4BAA4B,CAAC;AAC3B,gCAAA,IAAI,EAAE,WAAW,CAAC,EAAE,CAAC,IAAI;AACzB,gCAAA,OAAO,EAAEA,aAAO,CAAC,WAAW,CAAC;AAC7B,gCAAA,IAAI,EAAE,WAAW;AACjB,gCAAA,UAAU,EAAE,qBAAqB,CAAC,WAAW,CAAC;AAC/C,6BAAA,CAAC,CACH,CAAC;yBACH;6BAAM,IACL,YAAY,CAAgB,WAAW,CAAC,EAAE,EAAE,eAAe,CAAC,EAC5D;4BACA,WAAW,CAAC,EAAE,CAAC,UAAU,CAAC,OAAO,CAAC,CAAC,QAAQ,KAAI;AAC7C,gCAAA,IACE,YAAY,CAAiB,QAAQ,EAAE,gBAAgB,CAAC,EACxD;oCACA,IAAI,YAAY,CAAa,QAAQ,CAAC,GAAG,EAAE,YAAY,CAAC,EAAE;AACxD,wCAAA,qBAAqB,CAAC,IAAI,CACxB,4BAA4B,CAAC;AAC3B,4CAAA,IAAI,EAAE,QAAQ,CAAC,GAAG,CAAC,IAAI;AACvB,4CAAA,OAAO,EAAEA,aAAO,CAAC,WAAW,CAAC;AAC7B,4CAAA,IAAI,EAAE,WAAW;AACjB,4CAAA,UAAU,EAAE,qBAAqB,CAAC,WAAW,CAAC;AAC/C,yCAAA,CAAC,CACH,CAAC;qCACH;iCACF;AACH,6BAAC,CAAC,CAAC;yBACJ;6BAAM;4BACL,MAAM,IAAI,GAAG,WAAW,CAAC,EAAE,CAAC,QAAQ,EAAE,CAAC;4BACvC,IAAI,IAAI,EAAE;AACR,gCAAA,qBAAqB,CAAC,IAAI,CACxB,4BAA4B,CAAC;oCAC3B,IAAI;AACJ,oCAAA,OAAO,EAAEA,aAAO,CAAC,WAAW,CAAC;AAC7B,oCAAA,IAAI,EAAE,WAAW;AACjB,oCAAA,UAAU,EAAE,qBAAqB,CAAC,WAAW,CAAC;AAC/C,iCAAA,CAAC,CACH,CAAC;6BACH;yBACF;AACH,qBAAC,CACF,CAAC;iBACH;qBAAM,IACL,YAAY,CACV,qBAAqB,CAAC,WAAW,EACjC,kBAAkB,CACnB,EACD;oBACA,MAAM,eAAe,GAAG,CAAA,EAAA,GAAA,qBAAqB,CAAC,WAAW,CAAC,EAAE,MAAE,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,EAAA,CAAA,IAAI,CAAC;oBACnE,MAAM,oBAAoB,GACxB,CAAA,EAAA,GAAA,qBAAqB,CAAC,WAAW,CAAC,EAAE,MAAA,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,EAAA,CAAE,QAAQ,EAAE,CAAC;AACnD,oBAAA,MAAM,IAAI,GAAG,eAAe,IAAI,oBAAoB,IAAI,EAAE,CAAC;oBAE3D,IAAI,CAAC,IAAI,EAAE;AACT,wBAAA,MAAM,IAAI,KAAK,CAAC,8BAA8B,CAAC,CAAC;qBACjD;AAED,oBAAA,qBAAqB,CAAC,IAAI,CACxB,4BAA4B,CAAC;wBAC3B,IAAI;AACJ,wBAAA,OAAO,EAAE,IAAI;wBACb,IAAI,EAAE,qBAAqB,CAAC,WAAW;AACvC,wBAAA,UAAU,EAAE,qBAAqB,CAAC,qBAAqB,CAAC,WAAW,CAAC;AACrE,qBAAA,CAAC,CACH,CAAC;iBACH;qBAAM;AACL,oBAAA,MAAM,WAAW,GAAG,qBAAqB,CAAC,WAAW,CAAC;AACtD,oBAAA,IACE,YAAY,CACV,WAAW,EACX,6BAA6B,CAC9B,EACD,CACD;yBAAM;AACL,wBAAA,IAAI,WAAW,IAAI,IAAI,IAAI,WAAW,EAAE;4BACtC,IAAI,YAAY,CAAa,WAAW,CAAC,EAAE,EAAE,YAAY,CAAC,EAAE;AAC1D,gCAAA,MAAM,IAAI,GAAG,WAAW,CAAC,EAAE,CAAC,IAAI,CAAC;gCACjC,IAAI,IAAI,EAAE;AACR,oCAAA,qBAAqB,CAAC,IAAI,CACxB,4BAA4B,CAAC;wCAC3B,IAAI;AACJ,wCAAA,OAAO,EAAEA,aAAO,CAAC,WAAW,CAAC;AAC7B,wCAAA,IAAI,EAAE,WAAW;AACjB,wCAAA,UAAU,EAAE,qBAAqB,CAAC,WAAW,CAAC;AAC/C,qCAAA,CAAC,CACH,CAAC;iCACH;6BACF;iCAAM;AACL,gCAAA,qBAAqB,CAAC,IAAI,CACxB,4BAA4B,CAAC;oCAC3B,IAAI,EAAE,CAAA,CAAA,EAAA,GAAA,WAAW,CAAC,EAAE,MAAE,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,EAAA,CAAA,QAAQ,EAAE,KAAI,EAAE;AACtC,oCAAA,OAAO,EAAEA,aAAO,CAAC,WAAW,CAAC;AAC7B,oCAAA,IAAI,EAAE,WAAW;AACjB,oCAAA,UAAU,EAAE,qBAAqB,CAAC,WAAW,CAAC;AAC/C,iCAAA,CAAC,CACH,CAAC;6BACH;yBAGF;qBACF;iBACF;aACF;SACF;AAAM,aAAA,IACL,YAAY,CACV,gBAAgB,EAChB,sBAAsB,CACvB,EACD,CAED;aAAM;AACL,YAAA,MAAM,IAAI,KAAK,CAAC,8BAA8B,CAAC,CAAC;SACjD;KACF;AAED,IAAA,OAAO,qBAAqB,CAAC;AAC/B,CAAC;;ACxMD;;;;;;;;;;;;;;;;;AAiBG;AACU,MAAA,oBAAoB,GAAG,CAClC,IAAmB,KACS;AAC5B,IAAA,MAAM,GAAG,GAAS,OAAO,IAAI,KAAK,QAAQ,GAAG,mBAAmB,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC;AAE9E,IAAA,MAAM,gBAAgB,GAAG,GAAG,CAAC,OAAO,CAAC,IAAI,CAAC,MAAM,CAC9C,CAAC,QAA0B,KACzB,QAAQ,CAAC,IAAI,KAAK,wBAAwB;AAC1C,QAAA,QAAQ,CAAC,IAAI,KAAK,0BAA0B,CAC/C,CAAC;AAEF,IAAA,MAAM,gBAAgB,GAAG,gBAAgB,CAAC,MAAM,GAAG,CAAC,CAAC;IACrD,IAAI,gBAAgB,EAAE;AACpB,QAAA,OAAO,EAAE,CAAC;KACX;AAED,IAAA,MAAM,uBAAuB,GAAG;QAC9B,wBAAwB;QACxB,0BAA0B;KAC3B,CAAC;AAEF,IAAA,IAAI,CAAC,uBAAuB,CAAC,QAAQ,CAAC,gBAAgB,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE;;AAE/D,QAAA,MAAM,IAAI,KAAK,CACb,yHAAyH,CAC1H,CAAC;KACH;AAED,IAAA,OAAO,gBAAgB;SACpB,GAAG,CAAC,CAAC,SAAS,KAAK,0CAA0C,CAAC,SAAS,CAAC,CAAC;AACzE,SAAA,IAAI,EAAE,CAAC;AACZ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5CO,MAAM,iBAAiB,GAAG,CAC/B,GAAoC,KACb,SAAA,CAAA,KAAA,CAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,EAAA,aAAA;IACvB,IAAI,CAAC,GAAG,EAAE;AACR,QAAA,MAAM,IAAI,KAAK,CAAC,kDAAkD,CAAC,CAAC;KACrE;IAED,IAAI,GAAG,CAAC,QAAQ,CAAC,QAAQ,CAAC,QAAQ,CAAC,EAAE;QACnC,MAAM,QAAQ,GAAG,IAAI,CAAC,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;AAC7C,QAAA,MAAM,IAAI,KAAK,CAAC,aAAa,QAAQ,CAAA,yBAAA,CAA2B,CAAC,CAAC;KACnE;AAED,IAAA,MAAM,IAAI,GAAG,GAAG,CAAC,OAAO,EAAE,CAAC;AAC3B,IAAA,MAAM,QAAQ,GAAG,GAAG,CAAC,QAAQ,CAAC;IAC9B,MAAM,aAAa,GAAG,QAAQ,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,CAAC;AAEhD,IAAA,MAAM,oBAAoB,GAAG,GAAG,CAAC,GAAG,CAAC;IAErC,OAAO,EAAE,IAAI,EAAE,oBAAoB,EAAE,aAAa,EAAE,QAAQ,EAAE,CAAC;AACjE,CAAC,CAAA;;ACxBD;;;;AAIG;AACU,MAAA,WAAW,GAAG,CAAO,QAAiB,KAAI,SAAA,CAAA,KAAA,CAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,EAAA,aAAA;;IACrD,IAAI,IAAI,GAAG,EAAE,CAAC;IACd,IAAI,QAAQ,GAAG,EAAE,CAAC;IAClB,IAAI,aAAa,GAAG,EAAE,CAAC;IACvB,IAAI,oBAAoB,GAAGC,iBAAM,CAAC,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;IAE/C,IAAI,QAAQ,EAAE;QACZ,IAAI,GAAG,EAAE,CAAC,YAAY,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC;AACzC,QAAA,QAAQ,GAAG,QAAQ,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,IAAI,EAAE,CAAC;AAC3C,QAAA,aAAa,GAAG,QAAQ,CAAC,QAAQ,CAAC,GAAG,CAAC;cAClC,QAAQ,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,GAAG,EAAE,IAAI,EAAE;cAC/B,EAAE,CAAC;QACP,oBAAoB,GAAGA,iBAAM,CAAC,GAAG,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;KAClD;SAAM;QACL,MAAM,QAAQ,GAAG,CAAA,EAAA,GAAAA,iBAAM,CAAC,MAAM,CAAC,gBAAgB,MAAE,IAAA,IAAA,EAAA,KAAA,KAAA,CAAA,GAAA,KAAA,CAAA,GAAA,EAAA,CAAA,QAAQ,CAAC;AAC1D,QAAA,MAAM,YAAY,GAAG,MAAM,iBAAiB,CAAC,QAAQ,CAAC,CAAC;AACvD,QAAA,IAAI,GAAG,YAAY,CAAC,IAAI,CAAC;AACzB,QAAA,QAAQ,GAAG,YAAY,CAAC,QAAQ,CAAC;AACjC,QAAA,aAAa,GAAG,YAAY,CAAC,aAAa,IAAI,EAAE,CAAC;AACjD,QAAA,oBAAoB,GAAG,YAAY,CAAC,oBAAoB,CAAC;KAC1D;IAED,IAAI,CAAC,aAAa,EAAE;QAClB,aAAa,GAAG,IAAI,CAAC;KACtB;IAED,MAAM,GAAG,GAAG,IAAI,CAAC,OAAO,CAAC,oBAAoB,CAAC,MAAM,CAAC,CAAC;IAEtD,OAAO,EAAE,IAAI,EAAE,oBAAoB,EAAE,aAAa,EAAE,QAAQ,EAAE,GAAG,EAAE,CAAC;AACtE,CAAC;;;;;;;;;"}